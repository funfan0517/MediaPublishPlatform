# 视频发布系统前后端调用流程文档

## 1. 系统架构概述

本系统是一个多平台视频发布管理系统，采用前后端分离架构，支持抖音、快手、小红书、视频号等多个短视频平台的视频上传与发布。系统核心由前端Vue应用和Python后端服务组成，通过标准化的API接口实现数据交互。

### 1.1 整体架构图

```
+------------------+        +------------------+        +------------------+
|   前端Vue应用     |<------>|   Flask后端服务   |<------>|   各大视频平台    |
+------------------+        +------------------+        +------------------+
       ^                           ^
       |                           |
       v                           v
+------------------+        +------------------+
|   用户操作界面    |        |  SQLite数据库     |
+------------------+        |  文件存储         |
                            +------------------+
```

### 1.2 核心组件

1. **前端应用**：基于Vue构建的SPA应用，负责用户交互和数据展示
2. **后端服务**：基于Flask构建的RESTful API服务，处理业务逻辑和平台对接
3. **平台上传器**：各平台独立的上传模块，负责与平台API交互
4. **数据存储**：SQLite数据库存储账号信息和文件记录
5. **文件系统**：存储视频文件和Cookie文件

## 2. 标准化API接口规范

### 2.1 接口命名约定

- **文件管理接口**：以`file`开头，如`uploadFile`、`getFiles`
- **账号管理接口**：以`account`开头，如`getAccounts`、`updateAccount`
- **视频发布接口**：以`post`开头，如`postVideo`、`postVideoBatch`
- **登录认证接口**：以`login`开头
- **统计数据接口**：以`get`开头，如`getPlatformStats`

### 2.2 响应格式规范

所有API接口返回统一的JSON格式：

```json
{
  "code": 200,            // 状态码，200表示成功
  "msg": "success",       // 消息提示
  "data": {}             // 响应数据，根据接口不同而变化
}
```

### 2.3 核心API接口清单

| 接口路径 | 方法 | 功能描述 | 主要参数 |
|---------|------|---------|--------|
| `/login` | GET | 账号登录获取Cookie | type(平台类型), id(账号ID) |
| `/uploadSave` | POST | 上传视频文件 | file(文件), filename(文件名) |
| `/getFiles` | GET | 获取所有视频文件列表 | - |
| `/getFile` | GET | 获取单个视频文件 | filename(文件名) |
| `/deleteFile` | GET | 删除视频文件 | id(文件ID) |
| `/getAccounts` | GET | 获取所有账号信息 | - |
| `/updateUserinfo` | POST | 更新账号信息 | id, type, userName |
| `/deleteAccount` | GET | 删除账号 | id(账号ID) |
| `/postVideo` | POST | 发布单个视频 | fileList, accountList, type, title, tags等 |
| `/postVideoBatch` | POST | 批量发布视频 | 视频配置对象数组 |
| `/getPlatformStats` | GET | 获取平台统计数据 | - |
| `/getFileStats` | GET | 获取文件统计数据 | - |

## 3. 前后端交互流程详解

### 3.1 账号登录与Cookie管理流程

#### 3.1.1 前端调用流程

1. 前端选择平台类型（1=小红书，2=视频号，3=抖音，4=快手）
2. 发起GET请求到`/login`接口，传递平台类型和账号ID
3. 建立SSE连接，接收实时登录状态更新
4. 根据登录状态展示二维码或提示用户操作
5. 收到成功消息后，更新前端账号状态

```javascript
// 前端登录调用示例
function loginToPlatform(platformType, accountId) {
  const eventSource = new EventSource(`/login?type=${platformType}&id=${accountId}`);
  
  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    
    switch(data.status) {
      case 'qrcode':
        showQRCode(data.qrcodeUrl); // 显示登录二维码
        break;
      case 'scanned':
        showMessage('二维码已扫描，请确认'); // 二维码已扫描
        break;
      case 'success':
        showMessage('登录成功'); // 登录成功
        updateAccountStatus(accountId, 1); // 更新账号状态为有效
        eventSource.close();
        break;
      case 'error':
        showError(data.message); // 显示错误信息
        eventSource.close();
        break;
    }
  };
  
  eventSource.onerror = () => {
    showError('连接异常');
    eventSource.close();
  };
}
```

#### 3.1.2 后端处理流程

1. 接收`/login`接口请求，创建状态队列
2. 启动异步线程执行对应平台的Cookie生成函数
3. 通过SSE实时推送登录状态
4. Cookie生成成功后保存到对应账号的Cookie文件
5. 更新数据库中账号状态

```python
# 后端处理登录请求示例（基于Flask）
@app.route('/login')
def login():
    # 获取平台类型和账号ID
    type = request.args.get('type')
    id = request.args.get('id')

    # 创建状态队列
    status_queue = Queue()
    active_queues[id] = status_queue

    # 启动异步任务线程
    thread = threading.Thread(target=run_async_function, args=(type, id, status_queue), daemon=True)
    thread.start()
    
    # 返回SSE响应
    response = Response(sse_stream(status_queue,), mimetype='text/event-stream')
    response.headers['Cache-Control'] = 'no-cache'
    response.headers['X-Accel-Buffering'] = 'no'
    return response

# 根据平台类型调用对应Cookie生成函数
def run_async_function(type, id, status_queue):
    match type:
        case '1': asyncio.run(xiaohongshu_cookie_gen(id, status_queue))
        case '2': asyncio.run(get_tencent_cookie(id, status_queue))
        case '3': asyncio.run(douyin_cookie_gen(id, status_queue))
        case '4': asyncio.run(get_ks_cookie(id, status_queue))
```

### 3.2 视频文件上传流程

#### 3.2.1 前端上传流程

1. 用户选择本地视频文件
2. 前端通过FormData构造上传数据
3. 发起POST请求到`/uploadSave`接口
4. 监听上传进度（可选）
5. 接收上传成功响应，获取文件ID用于后续发布

```javascript
// 前端上传文件示例
async function uploadVideoFile(file, customFilename) {
  const formData = new FormData();
  formData.append('file', file);
  if (customFilename) {
    formData.append('filename', customFilename);
  }

  try {
    const response = await fetch('/uploadSave', {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    
    if (result.code === 200) {
      return result.data.filepath; // 返回文件路径
    } else {
      throw new Error(result.msg || '上传失败');
    }
  } catch (error) {
    console.error('文件上传失败:', error);
    throw error;
  }
}
```

#### 3.2.2 后端处理流程

1. 接收文件上传请求
2. 验证文件有效性
3. 生成UUID并保存文件到`videoFile`目录
4. 在数据库中记录文件信息
5. 返回文件路径供前端使用

```python
# 后端处理文件上传示例
@app.route('/uploadSave', methods=['POST'])
def upload_save():
    # 获取上传文件
    file = request.files['file']
    if not file or file.filename == '':
        return jsonify({"code": 400, "msg": "未选择文件", "data": None})
    
    # 生成UUID和保存路径
    uuid_v1 = uuid.uuid1()
    filename = request.form.get('filename', file.filename)
    final_filename = f"{uuid_v1}_{filename}"
    filepath = Path(BASE_DIR / "videoFile" / final_filename)
    
    # 保存文件
    file.save(filepath)
    
    # 记录到数据库
    with sqlite3.connect(Path(BASE_DIR / "db" / "database.db")) as conn:
        cursor = conn.cursor()
        cursor.execute('''
            INSERT INTO file_records (filename, filesize, file_path)
            VALUES (?, ?, ?)
        ''', (filename, round(float(os.path.getsize(filepath)) / (1024 * 1024), 2), final_filename))
        conn.commit()
    
    # 返回成功响应
    return jsonify({
        "code": 200,
        "msg": "文件上传成功",
        "data": {"filename": filename, "filepath": final_filename}
    })
```

### 3.3 视频发布流程（核心）

#### 3.3.1 前端发布流程

1. 用户选择要发布的视频文件和目标账号
2. 填写发布参数（标题、标签、分类、定时设置等）
3. 发起POST请求到`/postVideo`接口
4. 接收发布任务已提交的响应
5. （可选）轮询发布状态或等待通知

```javascript
// 前端发布视频示例
async function publishVideo(postData) {
  try {
    const response = await fetch('/postVideo', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(postData)
    });
    
    const result = await response.json();
    
    if (result.code === 200) {
      showMessage('发布任务已提交');
      return true;
    } else {
      throw new Error(result.msg || '发布失败');
    }
  } catch (error) {
    console.error('视频发布失败:', error);
    throw error;
  }
}

// 发布参数结构示例
const postParams = {
  fileList: ['uuid_视频文件名.mp4'],    // 视频文件路径列表
  accountList: ['账号cookie文件路径.json'],  // 账号列表
  type: 3,                           // 平台类型：1=小红书, 2=视频号, 3=抖音, 4=快手
  title: '视频标题',                   // 视频标题
  tags: '话题1 话题2 话题3',            // 话题标签
  category: 0,                       // 分类（部分平台需要）
  enableTimer: true,                 // 是否启用定时发布
  videosPerDay: 1,                   // 每天发布视频数量
  dailyTimes: ['12:00', '18:00'],     // 每日发布时间点
  startDays: 0,                      // 开始天数
  // 平台特定参数
  thumbnail_path: '封面图片路径',      // 抖音封面
  productLink: '商品链接',            // 抖音商品链接
  productTitle: '商品标题',           // 抖音商品标题
  is_draft: false                    // 视频号是否保存为草稿
};
```

#### 3.3.2 后端发布流程

1. 接收发布请求，解析参数
2. 根据平台类型分发到对应的处理函数
3. 处理函数生成完整文件路径，配置发布时间
4. 遍历账号和文件列表，执行发布
5. 调用对应平台的上传类执行实际发布操作

```python
# 后端处理视频发布示例
@app.route('/postVideo', methods=['POST'])
def postVideo():
    # 获取请求数据
    data = request.get_json()
    file_list = data.get('fileList', [])
    account_list = data.get('accountList', [])
    type = data.get('type')  # 平台类型
    
    # 其他参数
    title = data.get('title')
    tags = data.get('tags')
    category = data.get('category')
    enableTimer = data.get('enableTimer')
    # 更多参数...
    
    # 根据平台类型调用对应发布函数
    match type:
        case 1:  # 小红书
            post_video_xhs(title, file_list, tags, account_list, category, enableTimer, ...)
        case 2:  # 视频号
            post_video_tencent(title, file_list, tags, account_list, category, enableTimer, ..., is_draft)
        case 3:  # 抖音
            post_video_DouYin(title, file_list, tags, account_list, category, enableTimer, ..., thumbnail_path, productLink, productTitle)
        case 4:  # 快手
            post_video_ks(title, file_list, tags, account_list, category, enableTimer, ...)
    
    # 返回成功响应
    return jsonify({"code": 200, "msg": None, "data": None})

# 平台特定发布函数示例（以抖音为例）
def post_video_DouYin(title, files, tags, account_file, category, enableTimer, videos_per_day, daily_times, start_days, thumbnail_path, productLink, productTitle):
    # 生成完整文件路径
    account_file = [Path(BASE_DIR / "cookiesFile" / file) for file in account_file]
    files = [Path(BASE_DIR / "videoFile" / file) for file in files]
    
    # 生成发布时间
    if enableTimer:
        publish_datetimes = generate_schedule_time_next_day(len(files), videos_per_day, daily_times, start_days)
    else:
        publish_datetimes = [0] * len(files)
    
    # 遍历执行发布
    for index, file in enumerate(files):
        for cookie in account_file:
            # 实例化平台上传类
            app = DouYinVideo(title, str(file), tags, publish_datetimes[index], cookie, thumbnail_path, productLink, productTitle)
            # 执行上传
            asyncio.run(app.main(), debug=False)
```

## 4. 平台扩展指南

### 4.1 新增平台接入流程

要接入新平台（如TikTok），需要完成以下步骤：

1. **创建平台上传器模块**
   - 在`uploader`目录下创建新的平台文件夹（如`tiktok_uploader`）
   - 创建`main.py`文件实现核心上传逻辑
   - 遵循现有平台类的设计模式实现上传功能

2. **实现Cookie获取功能**
   - 在`myUtils/login.py`中添加新平台的Cookie生成函数
   - 创建对应示例文件（如`get_tiktok_cookie.py`）

3. **添加发布处理函数**
   - 在`myUtils/postVideo.py`中添加新平台的发布函数（如`post_video_tiktok`）
   - 创建对应示例文件（如`upload_video_to_tiktok.py`）

4. **更新后端API**
   - 在`sau_backend.py`的`/postVideo`接口中添加新平台的处理分支
   - 更新登录接口中的平台类型匹配

5. **更新前端界面**
   - 在前端界面添加新平台的选择选项
   - 根据平台特性调整发布表单字段

### 4.2 平台上传器设计规范

每个平台的上传器类应遵循以下设计模式：

```python
class PlatformVideo:
    def __init__(self, title, video_path, tags, publish_time, cookie_path, *platform_specific_args):
        """
        初始化平台视频上传器
        
        Args:
            title (str): 视频标题
            video_path (str): 视频文件路径
            tags (str): 话题标签，多个标签用空格分隔
            publish_time (int): 定时发布时间戳，0表示立即发布
            cookie_path (str): Cookie文件路径
            platform_specific_args: 平台特定参数
        """
        self.title = title
        self.video_path = video_path
        self.tags = tags
        self.publish_time = publish_time
        self.cookie_path = cookie_path
        # 初始化平台特定参数
        
    async def main(self):
        """
        主入口函数，协调整个上传流程
        """
        try:
            # 初始化浏览器
            await self.init_browser()
            
            # 加载Cookie
            await self.load_cookie()
            
            # 导航到上传页面
            await self.navigate_to_upload_page()
            
            # 上传视频
            await self.upload_video()
            
            # 设置视频信息（标题、标签等）
            await self.set_video_info()
            
            # 设置定时发布（如果需要）
            if self.publish_time:
                await self.set_schedule_time()
            
            # 设置平台特定信息
            await self.set_platform_specific_info()
            
            # 发布视频
            await self.publish()
            
            print(f"✅ 视频发布成功: {self.title}")
        except Exception as e:
            print(f"❌ 视频发布失败: {str(e)}")
            raise
        finally:
            # 关闭浏览器
            await self.close_browser()
    
    # 其他需要实现的方法...
```

### 4.3 API扩展规范

扩展API时应遵循以下原则：

1. **保持接口一致性**：新接口应遵循现有接口的命名和响应格式规范
2. **参数扩展**：对于平台特定参数，应在通用参数基础上进行扩展，而非修改现有参数
3. **向后兼容**：确保现有功能不受新平台接入的影响
4. **错误处理**：统一的错误处理机制，返回清晰的错误信息
5. **日志记录**：记录关键操作日志，便于调试和问题追踪

## 5. 关键技术实现

### 5.1 异步处理机制

系统采用`asyncio`库实现异步操作，提高并发性能，特别是在处理多账号、多文件的发布任务时。

```python
# 异步函数调用示例
async def main():
    # 异步初始化浏览器
    browser = await playwright.chromium.launch(headless=False)
    
    # 异步创建页面
    page = await browser.new_page()
    
    # 异步导航
    await page.goto('https://example.com')
    
    # 异步操作
    await page.fill('#username', 'user')
    await page.fill('#password', 'pass')
    await page.click('#login-button')
    
    # 异步关闭
    await browser.close()

# 运行异步函数
asyncio.run(main())
```

### 5.2 定时发布实现

系统通过`utils/files_times.py`中的`generate_schedule_time_next_day`函数生成定时发布时间表，支持灵活配置每天发布次数和时间点。

```python
# 生成定时发布时间表示例
def generate_schedule_time_next_day(file_count, videos_per_day, daily_times, start_days=0):
    """
    生成未来几天的定时发布时间表
    
    Args:
        file_count (int): 文件数量
        videos_per_day (int): 每天发布视频数量
        daily_times (list): 每日发布时间点列表，如['12:00', '18:00']
        start_days (int): 开始天数，默认为0（今天）
        
    Returns:
        list: 发布时间戳列表
    """
    # 实现逻辑...
    pass
```

### 5.3 Cookie管理机制

系统通过文件系统和数据库相结合的方式管理账号Cookie：

1. Cookie文件保存在`cookiesFile`目录下，以账号ID或名称命名
2. 数据库记录Cookie文件路径和账号状态
3. 提供Cookie文件上传和下载API，方便手动管理

```python
# Cookie文件上传API示例
@app.route('/uploadCookie', methods=['POST'])
def upload_cookie():
    # 获取上传的Cookie文件
    file = request.files['file']
    account_id = request.form.get('id')
    platform = request.form.get('platform')
    
    # 验证参数
    if not file or file.filename == '' or not account_id or not platform:
        return jsonify({"code": 400, "msg": "参数错误", "data": None})
    
    # 获取目标路径
    with sqlite3.connect(Path(BASE_DIR / "db" / "database.db")) as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT filePath FROM user_info WHERE id = ?', (account_id,))
        result = cursor.fetchone()
        
        if not result:
            return jsonify({"code": 404, "msg": "账号不存在", "data": None})
    
    # 保存Cookie文件
    cookie_file_path = Path(BASE_DIR / "cookiesFile" / result['filePath'])
    file.save(str(cookie_file_path))
    
    return jsonify({"code": 200, "msg": "Cookie文件上传成功", "data": None})
```

## 6. 代码优化建议

### 6.1 统一错误处理机制

建议实现统一的错误处理装饰器，简化API错误处理逻辑：

```python
def api_error_handler(func):
    """API错误处理装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            print(f"API错误: {str(e)}")
            return jsonify({
                "code": 500,
                "msg": str(e),
                "data": None
            }), 500
    return wrapper

# 使用示例
@app.route('/postVideo', methods=['POST'])
@api_error_handler
def postVideo():
    # 实现逻辑...
    pass
```

### 6.2 任务队列优化

当前实现在处理大量视频发布任务时可能存在性能瓶颈，建议引入任务队列机制：

```python
# 使用Celery实现异步任务队列
from celery import Celery

app = Celery('tasks', broker='redis://localhost:6379/0')

@app.task
def publish_video_task(platform_type, title, files, tags, accounts, **kwargs):
    """视频发布异步任务"""
    # 根据平台类型调用对应发布函数
    match platform_type:
        case 1: post_video_xhs(title, files, tags, accounts, **kwargs)
        case 2: post_video_tencent(title, files, tags, accounts, **kwargs)
        # 其他平台...

# 在API中调用异步任务
@app.route('/postVideo', methods=['POST'])
def postVideo():
    data = request.get_json()
    # 验证参数...
    
    # 提交异步任务
    task_id = publish_video_task.delay(
        data.get('type'),
        data.get('title'),
        data.get('fileList'),
        data.get('tags'),
        data.get('accountList'),
        # 其他参数...
    )
    
    return jsonify({
        "code": 200,
        "msg": "发布任务已提交",
        "data": {"task_id": task_id.id}
    })
```

### 6.3 数据库连接池

当前每次请求都创建新的数据库连接，建议使用连接池优化：

```python
# 使用SQLAlchemy管理数据库连接
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# 创建数据库引擎
engine = create_engine('sqlite:///db/database.db', pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 依赖项，用于获取数据库会话
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# 在路由中使用
@app.route('/getAccounts', methods=['GET'])
def getAccounts():
    db = next(get_db())
    try:
        accounts = db.query(UserInfo).all()
        return jsonify({
            "code": 200,
            "msg": None,
            "data": [account.to_dict() for account in accounts]
        })
    except Exception as e:
        return jsonify({
            "code": 500,
            "msg": str(e),
            "data": None
        })
```

## 7. 总结与展望

本文档详细描述了视频发布系统的前后端调用流程，包括账号登录、文件上传、视频发布等核心功能的实现细节。系统采用模块化设计，各平台的上传逻辑相对独立，便于扩展和维护。

未来可以考虑以下方向进行优化：

1. **接入更多平台**：按照本文档的扩展指南，逐步接入TikTok、Instagram等国际平台
2. **引入分布式任务队列**：使用Celery等工具优化大量视频的发布处理
3. **增强监控和报警机制**：实时监控发布状态，异常情况及时通知
4. **优化前端用户体验**：添加任务进度显示、批量操作等功能
5. **完善系统安全性**：加强文件验证、权限控制等安全措施

通过持续优化和扩展，系统可以支持更多平台、更高性能、更好的用户体验，满足不同场景下的视频发布需求。