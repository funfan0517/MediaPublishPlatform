# 后端集成新平台指南

## 1. 文档概述

本文档以Facebook平台为最新标准规范，详细描述了在视频发布系统中集成新的视频平台的完整流程和规范。遵循本文档的指导，可以快速、规范地将新平台集成到现有系统中，确保代码质量和系统稳定性。

**重要说明**：本文档已根据Facebook平台的实际实现进行了更新，作为新平台集成的标准模板。后续平台集成应严格遵循Facebook平台的实现模式。

## 2. 集成准备工作

### 2.1 环境要求

- Python 3.8+
- Flask
- Playwright (浏览器自动化)
- 其他依赖包 (见 requirements.txt)

### 2.2 平台调研

在开始集成前，需要对目标平台进行充分调研：

1. 平台的登录机制（账号密码、二维码、OAuth等）
2. 上传视频的限制（大小、时长、格式等）
3. 发布参数要求（标题、标签、分类等）
4. 是否支持定时发布功能
5. 平台特定的功能或限制

## 3. 集成步骤详解

### 3.1 创建平台上传器模块

#### 3.1.1 创建目录结构

在 `uploader` 目录下创建新的平台文件夹，例如 `newplatform_uploader`：

```
uploader/
└── newplatform_uploader/
    ├── __init__.py
    ├── main.py          # 核心上传实现（如使用Selenium）
    └── main_chrome.py   # Chrome/Playwright实现（可选）
```

对于Instagram平台，目录结构如下：
```
uploader/
└── ins_uploader/
    ├── __init__.py
    ├── main_chrome.py   # Instagram视频上传主类
    ├── instagram_logger.py  # Instagram专用日志模块
    └── config.py        # Instagram配置文件（可选）
```

#### 3.1.2 实现 `__init__.py`

```python
"""
NewPlatform平台上传器初始化文件
"""
from pathlib import Path
from conf import BASE_DIR

# 创建cookie存储目录
COOKIE_DIR = Path(BASE_DIR / "cookies" / "newplatform_uploader")
COOKIE_DIR.mkdir(parents=True, exist_ok=True)
```

#### 3.1.3 实现平台配置文件（可选）

如果平台有特殊的定位器或配置参数，可以创建专门的配置文件：

```python
"""
NewPlatform平台配置文件
"""

class NewPlatform_Locator:
    """NewPlatform平台元素定位器"""
    
    # 默认定位器
    default = {
        "login_button": "#login-button",
        "username_input": "#username",
        "password_input": "#password",
        "upload_button": "#upload-video",
        "file_input": "#video-file",
        "title_input": "#video-title",
        "tags_input": "#video-tags",
        "publish_button": "#publish-video"
    }
    
    # 特定场景下的定位器（如iframe内）
    iframe = {
        "frame_selector": "iframe#upload-frame",
        # iframe内的元素定位器
    }
```

#### 3.1.4 实现核心上传类（Facebook标准模式）

创建 `main_chrome.py` 文件，实现基于Playwright的上传逻辑。以下是基于Facebook平台实现的标准模板：

```python
# -*- coding: utf-8 -*-
"""
Facebook平台视频上传核心实现 - 标准模板
"""
import os
import asyncio
from datetime import datetime
from playwright.async_api import Playwright, async_playwright
from conf import LOCAL_CHROME_PATH, LOCAL_CHROME_HEADLESS
from utils.base_social_media import set_init_script
from utils.files_times import get_absolute_path
from utils.log import facebook_logger as logger


class FacebookVideo(object):
    """
    Facebook视频上传器类 - 标准实现模板
    
    Args:
        title (str): 视频标题
        file_path (str): 视频文件路径
        tags (str): 话题标签，多个标签用空格分隔
        publish_date (int): 定时发布时间戳，0表示立即发布
        account_file (str): Cookie文件路径
        thumbnail_path (str, optional): 缩略图路径
    """
    
    def __init__(self, title, file_path, tags, publish_date, account_file, thumbnail_path=None):
        self.title = title
        self.file_path = file_path
        self.tags = tags
        self.publish_date = publish_date
        self.thumbnail_path = thumbnail_path
        self.account_file = account_file
        self.local_executable_path = LOCAL_CHROME_PATH
        self.headless = LOCAL_CHROME_HEADLESS
        self.locator_base = None

    async def main(self):
        """
        主入口函数 - 标准流程
        """
        logger.info(f"开始上传视频: {self.title}")
        
        # 执行上传
        async with async_playwright() as playwright:
            await self.upload(playwright)

        logger.info(f"✅ Facebook视频发布成功: {self.title}")
        return True

    async def upload(self, playwright: Playwright) -> None:
        """
        核心上传流程 - 12步标准流程
        """
        logger.info(f'[+]Start Uploading-------{self.title}')
        
        # step1.创建浏览器实例
        browser = await playwright.chromium.launch(
            headless=self.headless, 
            executable_path=self.local_executable_path
        )
        logger.info("step1：浏览器实例已创建")

        # step2.创建上下文并加载cookie
        context = await browser.new_context(storage_state=f"{self.account_file}")
        context = await set_init_script(context)
        logger.info("step2：上下文已创建并加载cookie")

        # step3.创建新页面，导航到上传页面
        page = await context.new_page()
        platform_url = "https://www.facebook.com/"
        await page.goto(platform_url, wait_until='domcontentloaded', timeout=60000)
        logger.info("step3：创作中心页面已加载完成")
        
        # step4.选择基础定位器
        await self.choose_base_locator(page)
        logger.info("step4：基础定位器已选择")

        # step5.上传视频文件
        await self.upload_video_file(page)
        logger.info("step5：视频文件已上传")

        # step6.检测上传状态
        await self.detect_upload_status(page)
        logger.info("step6：视频上传状态检测完成")
        
        # step7.添加标题和标签
        await self.add_title_tags(page)
        logger.info("step7：标题和标签已添加")
        
        # step8.上传缩略图（如果有）
        if self.thumbnail_path:
            logger.info(f'[+] 上传缩略图文件 {self.title}')
            await self.upload_thumbnails(page)
            logger.info("step8：缩略图已上传")

        # step9.设置定时发布（如果需要）
        if self.publish_date != 0:
            await self.set_schedule_time(page, self.publish_date)
            logger.info("step9：定时发布时间已设置")

        # step10.点击发布
        await self.click_publish(page)
        logger.info("step10：视频已发布")   

        # step11.重新保存最新cookie
        await context.storage_state(path=f"{self.account_file}")  
        logger.info("step11：cookie已更新")
        await asyncio.sleep(2)  # close delay for look the video status
        
        # step12.关闭所有页面和浏览器上下文
        await context.close()
        await browser.close()
        logger.info("step12：浏览器实例已关闭")

    async def choose_base_locator(self, page):
        """
        选择基础定位器 - 标准实现
        """
        # 大多数平台不需要iframe处理，直接使用page
        self.locator_base = page

    async def upload_video_file(self, page):
        """
        上传视频文件 - 标准实现
        """
        try:
            # 点击上传按钮（照片/视频）
            platform_upload_selector = 'div[aria-label="照片/视频"]'  # 根据平台调整
            logger.info(f"  [-] 将点击上传视频按钮: {platform_upload_selector}")
            upload_button = self.locator_base.locator(platform_upload_selector)
            await upload_button.wait_for(state='visible', timeout=30000)
            
            # 上传按钮，需要点击触发系统文件选择器
            async with page.expect_file_chooser() as fc_info:
                await upload_button.click()
            file_chooser = await fc_info.value
            await file_chooser.set_files(self.file_path)
            logger.info(f"通过系统文件选择器上传文件: {self.file_path}")
        except Exception as e:
            logger.error(f"选择视频文件失败: {str(e)}")
            raise
    
    async def upload_video(self):
        """
        上传视频文件
        """
        try:
            # 确保视频文件存在
            if not os.path.exists(self.video_path):
                raise FileNotFoundError(f"视频文件不存在: {self.video_path}")
            
            # 上传文件
            file_input = await self.page.query_selector('input[type="file"]')
            if not file_input:
                raise Exception("未找到文件上传元素")
            
            await file_input.set_input_files(self.video_path)
            logger.info(f"开始上传视频: {self.video_path}")
            
            # 等待上传完成（这里需要根据平台特性自定义等待逻辑）
            await self.page.wait_for_selector('.upload-complete-indicator', timeout=300000)  # 5分钟超时
            logger.info("视频上传完成")
        except Exception as e:
            logger.error(f"视频上传失败: {str(e)}")
            raise
    
    async def set_video_info(self):
        """
        设置视频信息（标题、标签等）
        """
        try:
            # 设置标题
            title_input = await self.page.query_selector('#video-title')
            if title_input:
                await title_input.fill(self.title)
            
            # 设置标签
            tags_input = await self.page.query_selector('#video-tags')
            if tags_input:
                await tags_input.fill(self.tags)
            
            logger.info(f"成功设置视频信息: 标题='{self.title}', 标签='{self.tags}'")
        except Exception as e:
            logger.error(f"设置视频信息失败: {str(e)}")
            raise
    
    async def set_schedule_time(self):
        """
        设置定时发布时间
        """
        try:
            if self.publish_time <= 0:
                return  # 不需要定时发布
            
            # 点击定时发布按钮
            schedule_button = await self.page.query_selector('#schedule-button')
            if not schedule_button:
                logger.warning("未找到定时发布按钮，跳过定时设置")
                return
            
            await schedule_button.click()
            
            # 解析时间戳并设置日期时间（这里需要根据平台的时间选择器特性自定义）
            publish_datetime = datetime.fromtimestamp(self.publish_time)
            
            # 示例：设置日期和时间
            await self.page.fill('#date-input', publish_datetime.strftime('%Y-%m-%d'))
            await self.page.fill('#time-input', publish_datetime.strftime('%H:%M'))
            
            logger.info(f"成功设置定时发布时间: {publish_datetime}")
        except Exception as e:
            logger.error(f"设置定时发布时间失败: {str(e)}")
            raise
    
    async def set_platform_specific_info(self):
        """
        设置平台特定信息
        """
        try:
            # 根据平台特定参数设置额外信息
            # 例如：商品链接、封面选择、分类设置等
            if self.platform_specific_params:
                logger.info(f"应用平台特定参数: {self.platform_specific_params}")
                # 这里添加平台特定的设置逻辑
        except Exception as e:
            logger.error(f"设置平台特定信息失败: {str(e)}")
            raise
    
    async def publish(self):
        """
        发布视频
        """
        try:
            # 点击发布按钮
            publish_button = await self.page.query_selector('#publish-button')
            if not publish_button:
                raise Exception("未找到发布按钮")
            
            # 等待发布完成（这里需要根据平台特性自定义等待逻辑）
            async with self.page.expect_navigation(timeout=300000):
                await publish_button.click()
            
            logger.info(f"视频发布成功: {self.title}")
        except Exception as e:
            logger.error(f"视频发布失败: {str(e)}")
            raise
    
    async def close_browser(self):
        """
        关闭浏览器
        """
        try:
            if self.browser:
                await self.browser.close()
                logger.info("浏览器已关闭")
        except Exception as e:
            logger.error(f"关闭浏览器失败: {str(e)}")
    
    async def main(self):
        """
        主入口函数，协调整个上传流程
        """
        try:
            # 初始化浏览器
            await self.init_browser()
            
            # 加载Cookie
            await self.load_cookie()
            
            # 导航到上传页面
            await self.navigate_to_upload_page()
            
            # 上传视频
            await self.upload_video()
            
            # 设置视频信息（标题、标签等）
            await self.set_video_info()
            
            # 设置定时发布（如果需要）
            if self.publish_time > 0:
                await self.set_schedule_time()
            
            # 设置平台特定信息
            await self.set_platform_specific_info()
            
            # 发布视频
            await self.publish()
            
            logger.info(f"✅ 视频发布成功: {self.title}")
            return True
        except Exception as e:
            logger.error(f"❌ 视频发布失败: {str(e)}")
            raise
        finally:
            # 关闭浏览器
            await self.close_browser()

# 主函数调用示例
async def run_upload(title, video_path, tags, publish_time, cookie_path, **kwargs):
    """
    运行上传任务
    
    Args:
        title (str): 视频标题
        video_path (str): 视频文件路径
        tags (str): 标签
        publish_time (int): 发布时间戳
        cookie_path (str): Cookie路径
        **kwargs: 额外参数
    """
    uploader = NewPlatformVideo(title, video_path, tags, publish_time, cookie_path, **kwargs)
    return await uploader.main()

if __name__ == "__main__":
    # 示例运行代码
    asyncio.run(run_upload(
        "测试视频",
        "videos/demo.mp4",
        "测试 标签",
        0,  # 立即发布
        "cookies/newplatform_cookie.json"
    ))
```

### 3.2 实现Cookie获取功能（Facebook标准模式）

#### 3.2.1 在 `myUtils/login.py` 中添加新平台的Cookie生成函数（基于Facebook实现）

```python
async def newplatform_cookie_gen(account_id, status_queue):
    """
    生成NewPlatform平台的Cookie - Facebook标准模式
    
    Args:
        account_id (str): 账号ID
        status_queue (Queue): 状态队列，用于返回登录状态
    """
    try:
        from pathlib import Path
        from conf import BASE_DIR
        from playwright.async_api import async_playwright
        
        # 创建cookie保存目录
        cookie_dir = Path(BASE_DIR / "cookiesFile")
        cookie_dir.mkdir(parents=True, exist_ok=True)
        
        cookie_file = cookie_dir / f"{account_id}_newplatform.json"
        
        async with async_playwright() as p:
            # 启动浏览器（必须使用有头模式以便用户交互）
            browser = await p.chromium.launch(
                headless=False,
                args=['--disable-blink-features=AutomationControlled']
            )
            page = await browser.new_page()
            
            # 发送开始登录状态
            status_queue.put({"status": "start", "message": "开始登录NewPlatform"})
            
            # 导航到登录页面
            await page.goto("https://www.newplatform.com/login", wait_until='domcontentloaded')
            
            # 等待用户手动登录
            status_queue.put({"status": "waiting", "message": "请在浏览器中完成登录，登录成功后系统会自动保存Cookie"})
            
            # 等待登录成功的标识（需要根据平台特性自定义）
            # Facebook使用特定的选择器来判断登录成功
            await page.wait_for_selector('[data-testid="royal_nav"]', timeout=300000)  # 5分钟超时让用户登录
            
            # 登录成功，获取并保存Cookie
            cookies = await page.context.cookies()
            
            with open(cookie_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            # 发送成功状态
            status_queue.put({"status": "success", "message": f"登录成功，Cookie已保存到: {cookie_file}"})
            
            # 关闭浏览器
            await browser.close()
            
    except Exception as e:
        status_queue.put({"status": "error", "message": f"获取Cookie失败: {str(e)}"})
        raise
```

#### 3.2.2 创建Cookie获取示例文件

在 `examples` 目录下创建 `get_newplatform_cookie.py`：

```python
"""
NewPlatform平台Cookie获取示例
"""
import asyncio
import json
from pathlib import Path
from conf import BASE_DIR

async def get_newplatform_cookie():
    """
    获取NewPlatform平台Cookie
    """
    try:
        from playwright.async_api import async_playwright
        
        # 创建cookie保存目录
        cookie_dir = Path(BASE_DIR / "cookiesFile")
        cookie_dir.mkdir(parents=True, exist_ok=True)
        
        cookie_file = cookie_dir / "newplatform_cookie.json"
        
        async with async_playwright() as p:
            # 启动浏览器
            browser = await p.chromium.launch(headless=False)
            page = await browser.new_page()
            
            print("正在打开NewPlatform登录页面，请手动登录...")
            
            # 导航到登录页面
            await page.goto("https://www.newplatform.com/login")
            
            # 等待用户手动登录完成
            print("请在浏览器中完成登录操作")
            
            # 等待登录成功的标识（需要根据平台特性自定义）
            await page.wait_for_selector('.user-avatar', timeout=300000)  # 5分钟超时
            
            # 获取并保存Cookie
            cookies = await page.context.cookies()
            
            with open(cookie_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            print(f"✅ Cookie已成功保存到: {cookie_file}")
            
            # 关闭浏览器
            await browser.close()
            
    except Exception as e:
        print(f"❌ 获取Cookie失败: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(get_newplatform_cookie())
```

在 `examples` 目录下创建 `get_instagram_cookie.py`：

```python
"""
Instagram平台Cookie获取示例
"""
import asyncio
import json
from pathlib import Path
from conf import BASE_DIR

async def get_instagram_cookie():
    """
    获取Instagram平台Cookie
    """
    try:
        from playwright.async_api import async_playwright
        
        # 创建cookie保存目录
        cookie_dir = Path(BASE_DIR / "cookiesFile")
        cookie_dir.mkdir(parents=True, exist_ok=True)
        
        cookie_file = cookie_dir / "instagram_cookie.json"
        
        async with async_playwright() as p:
            # 启动浏览器
            browser = await p.chromium.launch(headless=False)
            page = await browser.new_page()
            
            print("正在打开Instagram登录页面，请手动登录...")
            
            # 导航到登录页面
            await page.goto("https://www.instagram.com/accounts/login/")
            
            # 等待用户手动登录完成
            print("请在浏览器中完成登录操作")
            
            # 等待登录成功的标识（Instagram登录成功后会重定向到主页）
            await page.wait_for_selector('svg[aria-label="主页"]', timeout=300000)  # 5分钟超时
            
            # 获取并保存Cookie
            cookies = await page.context.cookies()
            
            with open(cookie_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            print(f"✅ Instagram Cookie已成功保存到: {cookie_file}")
            
            # 关闭浏览器
            await browser.close()
            
    except Exception as e:
        print(f"❌ 获取Instagram Cookie失败: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(get_instagram_cookie())
```

### 3.3 添加发布处理函数

#### 3.3.1 在 `myUtils/postVideo.py` 中添加新平台的发布函数（Facebook标准模式）

```python
def post_video_newplatform(title, files, tags, account_file, category, enableTimer, videos_per_day, daily_times, start_days, **platform_specific_args):
    """
    发布视频到NewPlatform平台 - Facebook标准模式
    
    Args:
        title (str): 视频标题
        files (list): 视频文件路径列表
        tags (str): 标签
        account_file (list): 账号cookie文件路径列表
        category (int): 分类
        enableTimer (bool): 是否启用定时发布
        videos_per_day (int): 每天发布视频数量
        daily_times (list): 每日发布时间点列表
        start_days (int): 开始天数
        **platform_specific_args: 平台特定参数
    """
    import asyncio
    from utils.files_times import generate_schedule_time_next_day
    
    try:
        # 导入平台上传器 - 使用Facebook标准模式
        from uploader.newplatform_uploader.main_chrome import FacebookVideo
        
        # 生成发布时间
        if enableTimer:
            publish_datetimes = generate_schedule_time_next_day(len(files), videos_per_day, daily_times, start_days)
        else:
            publish_datetimes = [0] * len(files)
        
        # 遍历执行发布
        for index, file in enumerate(files):
            for cookie in account_file:
                # 创建上传器实例 - Facebook标准模式
                uploader = FacebookVideo(
                    title=title,
                    file_path=str(file),
                    tags=tags,
                    publish_date=publish_datetimes[index],
                    account_file=str(cookie),
                    thumbnail_path=platform_specific_args.get('thumbnail_path')
                )
                
                # 执行上传
                asyncio.run(uploader.main())
        
        return True
    except Exception as e:
        print(f"发布视频到NewPlatform失败: {str(e)}")
        raise
```

#### 3.3.2 创建视频上传示例文件

在 `examples` 目录下创建 `upload_video_to_newplatform.py`：

```python
"""
上传视频到NewPlatform平台示例 - Facebook标准模式
"""
import asyncio
from pathlib import Path
from conf import BASE_DIR

async def upload_to_newplatform():
    """
    上传视频到NewPlatform平台 - 使用FacebookVideo标准类
    """
    try:
        # 导入平台上传器 - 使用Facebook标准模式
        from uploader.newplatform_uploader.main_chrome import FacebookVideo
        
        # 视频文件路径
        video_path = Path(BASE_DIR / "videos/demo.mp4")
        
        # Cookie文件路径
        cookie_path = Path(BASE_DIR / "cookiesFile/newplatform_cookie.json")
        
        # 创建上传器实例 - Facebook标准模式
        uploader = FacebookVideo(
            title="测试视频标题",
            file_path=str(video_path),
            tags="测试 标签 示例",
            publish_date=0,  # 立即发布
            account_file=str(cookie_path),
            thumbnail_path=None  # 可选：缩略图路径
        )
        
        # 执行上传
        await uploader.main()
        
        print("✅ 视频上传成功")
        
    except Exception as e:
        print(f"❌ 视频上传失败: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(upload_to_newplatform())
```

在 `examples` 目录下创建 `upload_video_to_instagram.py`：

```python
"""
上传视频到Instagram平台示例
"""
import asyncio
from pathlib import Path
from conf import BASE_DIR

async def upload_to_instagram():
    """
    上传视频到Instagram平台
    """
    try:
        # 导入平台上传器
        from uploader.ins_uploader.main_chrome import InstagramVideo
        
        # 视频文件路径
        video_path = Path(BASE_DIR / "videos/demo.mp4")
        
        # Cookie文件路径
        cookie_path = Path(BASE_DIR / "cookiesFile/instagram_cookie.json")
        
        # 创建上传器实例
        uploader = InstagramVideo(
            title="Instagram测试视频标题",
            video_path=str(video_path),
            tags="测试 标签 Instagram",
            publish_time=0,  # 立即发布
            cookie_path=str(cookie_path)
            # 可以添加Instagram平台特定参数
        )
        
        # 执行上传
        await uploader.main()
        
        print("✅ Instagram视频上传成功")
        
    except Exception as e:
        print(f"❌ Instagram视频上传失败: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(upload_to_instagram())
```

### 3.4 更新后端API

#### 3.4.1 更新登录接口（Facebook标准模式）

在 `sau_backend.py` 的登录接口中添加新平台的处理分支：

```python
# 在run_async_function函数中添加新平台的处理 - Facebook标准模式
async def run_async_function(type, id, status_queue):
    match type:
        case '1': await xiaohongshu_cookie_gen(id, status_queue)
        case '2': await get_tencent_cookie(id, status_queue)
        case '3': await douyin_cookie_gen(id, status_queue)
        case '4': await get_ks_cookie(id, status_queue)
        case '5': await newplatform_cookie_gen(id, status_queue)  # 添加新平台 - Facebook标准模式
        case '6': await get_instagram_cookie(id, status_queue)  # Instagram平台
        case '7': await get_facebook_cookie(id, status_queue)  # Facebook平台 - 标准模式
```

#### 3.4.2 更新视频发布接口（Facebook标准模式）

在 `sau_backend.py` 的 `/postVideo` 接口中添加新平台的处理分支：

```python
@app.route('/postVideo', methods=['POST'])
def postVideo():
    # 获取请求数据
    data = request.get_json()
    file_list = data.get('fileList', [])
    account_list = data.get('accountList', [])
    type = data.get('type')  # 平台类型
    
    # 其他参数
    title = data.get('title')
    tags = data.get('tags')
    category = data.get('category')
    enableTimer = data.get('enableTimer')
    videos_per_day = data.get('videosPerDay', 1)
    daily_times = data.get('dailyTimes', ['00:00'])
    start_days = data.get('startDays', 0)
    
    # 平台特定参数 - Facebook标准模式支持缩略图等参数
    # 提取新平台特定参数
    newplatform_params = {}
    # 根据平台需要提取特定参数
    if data.get('thumbnail_path'):
        newplatform_params['thumbnail_path'] = data.get('thumbnail_path')
    
    # 根据平台类型调用对应发布函数 - Facebook标准模式
    match type:
        case 1:  # 小红书
            post_video_xhs(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days)
        case 2:  # 视频号
            post_video_tencent(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days, data.get('is_draft', False))
        case 3:  # 抖音
            post_video_DouYin(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days, data.get('thumbnail_path'), data.get('productLink'), data.get('productTitle'))
        case 4:  # 快手
            post_video_ks(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days)
        case 5:  # 新平台 - Facebook标准模式
            post_video_newplatform(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days, **newplatform_params)
        case 6:  # Instagram
            post_video_Instagram(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days)
        case 7:  # Facebook - 标准模式
            post_video_Facebook(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days, **newplatform_params)
    
    # 返回成功响应
    return jsonify({"code": 200, "msg": None, "data": None})
```

## 4. 平台特定功能实现指南

### 4.1 定时发布功能（Facebook标准模式）

不同平台的定时发布实现方式可能不同，Facebook标准模式采用以下方式：

1. **时间戳方式**：直接传入Unix时间戳
2. **上传器支持**：FacebookVideo类原生支持publish_date参数
3. **日期时间选择器**：需要分别设置日期和时间
4. **相对时间**：如设置为几小时后发布

实现时需要根据平台的具体API或界面进行适配。

```python
def convert_to_timestamp(datetime_str):
    """
    将日期时间字符串转换为时间戳 - Facebook标准模式
    """
    from datetime import datetime
    dt = datetime.strptime(datetime_str, '%Y-%m-%d %H:%M:%S')
    return int(dt.timestamp())

# FacebookVideo类中的定时发布处理
async def set_schedule_time(self, page, publish_date):
    """
    设置定时发布时间 - Facebook标准模式
    """
    if publish_date and publish_date > 0:
        # 转换为datetime对象
        schedule_time = datetime.fromtimestamp(publish_date)
        
        # 点击定时发布按钮
        schedule_button = await page.wait_for_selector('button[aria-label="定时发布"]')
        await schedule_button.click()
        
        # 设置日期和时间
        await page.fill('input[type="date"]', schedule_time.strftime('%Y-%m-%d'))
        await page.fill('input[type="time"]', schedule_time.strftime('%H:%M'))
        
        print(f"定时发布已设置：{schedule_time.strftime('%Y-%m-%d %H:%M:%S')}")
```

### 4.2 封面设置功能（Facebook标准模式）

封面设置的实现方式：

1. **自动生成**：平台自动从视频中提取帧
2. **自定义上传**：允许上传自定义图片作为封面
3. **帧选择**：从视频中选择特定帧作为封面
4. **缩略图支持**：FacebookVideo类原生支持thumbnail_path参数

实现代码示例（Facebook标准模式）：

```python
async def upload_thumbnails(self, page):
    """
    上传缩略图 - Facebook标准模式
    """
    if not self.thumbnail_path:
        return
        
    try:
        # 等待缩略图上传区域
        thumbnail_area = await page.wait_for_selector('div[aria-label="添加缩略图"]')
        await thumbnail_area.click()
        
        # 等待文件输入元素
        file_input = await page.wait_for_selector('input[type="file"]', state='visible')
        await file_input.set_input_files(self.thumbnail_path)
        
        # 等待上传完成
        await page.wait_for_selector('div[aria-label="缩略图预览"]', timeout=30000)
        logger.info(f"缩略图上传完成：{self.thumbnail_path}")
        
    except Exception as e:
        logger.warning(f"缩略图上传失败：{str(e)}")
        # 继续执行，不中断主流程

# 在FacebookVideo类构造函数中支持缩略图参数
def __init__(self, title, file_path, tags, publish_date, account_file, thumbnail_path=None):
    """
    初始化FacebookVideo上传器 - 支持缩略图参数
    """
    self.title = title
    self.file_path = file_path
    self.tags = tags
    self.publish_date = publish_date
    self.account_file = account_file
    self.thumbnail_path = thumbnail_path  # 新增缩略图支持
```

### 4.3 商品链接功能（Facebook标准模式）

电商相关平台通常支持添加商品链接，Facebook标准模式实现方式：

1. **链接添加**：在视频描述或特定区域添加商品链接
2. **链接验证**：验证链接的有效性和可访问性
3. **链接展示**：确保链接在视频页面中正确显示
4. **描述集成**：将商品链接集成到视频描述中

```python
async def add_product_links(self, page):
    """
    添加商品链接 - Facebook标准模式
    """
    if not hasattr(self, 'product_links') or not self.product_links:
        return
        
    try:
        # 等待描述区域
        description_area = await page.wait_for_selector('div[aria-label="视频描述"]')
        await description_area.click()
        
        # 构建包含商品链接的描述文本
        description_text = self.title + "\n\n"
        for i, link in enumerate(self.product_links, 1):
            description_text += f"商品链接{i}: {link}\n"
        
        # 输入描述
        await page.fill('div[aria-label="视频描述"]', description_text)
        print(f"已添加 {len(self.product_links)} 个商品链接")
        
    except Exception as e:
        print(f"添加商品链接失败：{str(e)}")
        # 继续执行，不中断主流程

# 在FacebookVideo类中支持商品链接参数
def __init__(self, title, file_path, tags, publish_date, account_file, thumbnail_path=None, product_links=None):
    """
    初始化FacebookVideo上传器 - 支持商品链接参数
    """
    self.title = title
    self.file_path = file_path
    self.tags = tags
    self.publish_date = publish_date
    self.account_file = account_file
    self.thumbnail_path = thumbnail_path
    self.product_links = product_links or []  # 新增商品链接支持
```

## 5. 测试与验证

### 5.1 单元测试（Facebook标准模式）

为新平台上传器编写单元测试，确保核心功能正常。Facebook标准模式测试：

```python
"""
FacebookVideo上传器单元测试 - Facebook标准模式
"""
import unittest
from unittest.mock import patch, MagicMock, AsyncMock
import asyncio
from uploader.newplatform_uploader.main_chrome import FacebookVideo

class TestFacebookVideo(unittest.TestCase):
    
    def setUp(self):
        """
        测试前置设置 - Facebook标准模式
        """
        self.title = "测试视频"
        self.file_path = "test_video.mp4"
        self.tags = "测试 标签"
        self.publish_date = 0
        self.account_file = "test_cookie.json"
        self.thumbnail_path = "test_thumbnail.jpg"
        self.product_links = ["https://example.com/product1"]
        
        self.uploader = FacebookVideo(
            title=self.title,
            file_path=self.file_path,
            tags=self.tags,
            publish_date=self.publish_date,
            account_file=self.account_file,
            thumbnail_path=self.thumbnail_path,
            product_links=self.product_links
        )
    
    def test_init_facebook_standard(self):
        """
        测试初始化 - Facebook标准模式
        """
        self.assertEqual(self.uploader.title, self.title)
        self.assertEqual(self.uploader.file_path, self.file_path)
        self.assertEqual(self.uploader.tags, self.tags)
        self.assertEqual(self.uploader.publish_date, self.publish_date)
        self.assertEqual(self.uploader.account_file, self.account_file)
        self.assertEqual(self.uploader.thumbnail_path, self.thumbnail_path)
        self.assertEqual(self.uploader.product_links, self.product_links)
    
    @patch('builtins.open')
    @patch('json.load')
    def test_load_cookie_success_facebook(self, mock_json_load, mock_open):
        """
        测试Cookie加载成功 - Facebook标准模式
        """
        mock_json_load.return_value = {"test": "cookie"}
        result = self.uploader.load_cookie()
        self.assertEqual(result, {"test": "cookie"})
    
    @patch('builtins.open')
    def test_load_cookie_file_not_found_facebook(self, mock_open):
        """
        测试Cookie文件不存在 - Facebook标准模式
        """
        mock_open.side_effect = FileNotFoundError()
        result = self.uploader.load_cookie()
        self.assertIsNone(result)
    
    @patch('asyncio.sleep', new_callable=AsyncMock)
    async def test_upload_thumbnail_facebook(self, mock_sleep):
        """
        测试缩略图上传 - Facebook标准模式
        """
        # 创建模拟页面
        mock_page = AsyncMock()
        mock_page.wait_for_selector = AsyncMock()
        mock_page.click = AsyncMock()
        mock_page.set_input_files = AsyncMock()
        
        # 执行缩略图上传
        await self.uploader.upload_thumbnail(mock_page)
        
        # 验证调用
        mock_page.wait_for_selector.assert_called()
        mock_page.click.assert_called()
        mock_page.set_input_files.assert_called()
    
    def test_facebook_standard_features(self):
        """
        测试Facebook标准模式特性
        """
        # 测试12步标准流程方法存在性
        self.assertTrue(hasattr(self.uploader, 'main'))
        self.assertTrue(hasattr(self.uploader, 'upload'))
        self.assertTrue(hasattr(self.uploader, 'upload_video_file'))
        self.assertTrue(hasattr(self.uploader, 'set_video_info'))
        self.assertTrue(hasattr(self.uploader, 'upload_thumbnail'))
        self.assertTrue(hasattr(self.uploader, 'add_product_links'))
        self.assertTrue(hasattr(self.uploader, 'choose_base_locator'))
        self.assertTrue(hasattr(self.uploader, 'detect_upload_status'))
    
    @patch('uploader.newplatform_uploader.main_chrome.async_playwright')
    async def test_browser_initialization_facebook(self, mock_playwright):
        """
        测试浏览器初始化 - Facebook标准模式
        """
        # 模拟浏览器初始化
        mock_browser = MagicMock()
        mock_page = MagicMock()
        mock_context = MagicMock()
        
        mock_context_manager = MagicMock()
        mock_context_manager.__aenter__.return_value = mock_context
        mock_context.chromium.launch.return_value = mock_browser
        mock_browser.new_page.return_value = mock_page
        mock_playwright.return_value = mock_context_manager
        
        # 测试浏览器初始化
        browser, page = await self.uploader.create_browser()
        
        # 验证调用
        mock_playwright.assert_called_once()
        mock_context.chromium.launch.assert_called_once()
        mock_browser.new_page.assert_called_once()

if __name__ == '__main__':
    unittest.main()
```

### 5.2 集成测试

进行端到端的集成测试，验证完整的上传流程：

1. 使用示例脚本测试Cookie获取功能
2. 使用示例脚本测试视频上传功能
3. 通过API接口测试完整的发布流程

### 5.3 常见问题排查

| 问题 | 可能原因 | 解决方案 |
|------|---------|--------|
| Cookie过期 | 平台Cookie有效期限制 | 实现Cookie自动刷新机制 |
| 上传超时 | 视频文件过大或网络问题 | 增加超时时间，优化上传逻辑 |
| 元素定位失败 | 平台页面更新 | 更新元素定位器，增加错误恢复机制 |
| 登录失败 | 账号密码错误或验证码 | 改进登录流程，增加用户交互提示 |

## 6. 性能优化建议

### 6.1 并发上传优化（Facebook标准模式）

对于多视频、多账号的发布场景，可以使用并发优化。Facebook标准模式实现：

```python
async def batch_upload_videos_facebook(video_tasks):
    """
    并发上传多个视频 - Facebook标准模式
    
    Args:
        video_tasks (list): 视频任务列表，每个任务包含上传所需的参数
    """
    # 设置并发限制 - Facebook推荐3个并发
    semaphore = asyncio.Semaphore(3)  # 最多同时执行3个上传任务
    
    async def upload_with_limit(task_params):
        async with semaphore:
            # 使用FacebookVideo类 - Facebook标准模式
            uploader = FacebookVideo(**task_params)
            return await uploader.main()
    
    # 创建任务并等待全部完成
    tasks = [upload_with_limit(params) for params in video_tasks]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # 处理结果
    success_count = sum(1 for r in results if isinstance(r, bool) and r)
    error_count = sum(1 for r in results if isinstance(r, Exception))
    
    return {
        "total": len(results),
        "success": success_count,
        "error": error_count,
        "errors": [str(r) for r in results if isinstance(r, Exception)]
    }

# Facebook标准模式批量上传示例
async def facebook_batch_upload_example():
    """
    Facebook标准模式批量上传示例
    """
    video_tasks = [
        {
            "title": f"测试视频{i}",
            "file_path": f"video{i}.mp4",
            "tags": "测试,批量上传",
            "publish_date": 0,
            "account_file": f"cookie{i}.json",
            "thumbnail_path": f"thumbnail{i}.jpg"
        }
        for i in range(1, 6)  # 5个视频任务
    ]
    
    # 执行批量上传
    results = await batch_upload_videos_facebook(video_tasks)
    print(f"批量上传完成: {results}")
```

### 6.2 重试机制实现（Facebook标准模式）

增加自动重试机制，提高上传成功率。Facebook标准模式实现：

```python
async def upload_with_retry_facebook(uploader, max_retries=3):
    """
    带重试机制的上传函数 - Facebook标准模式
    
    Args:
        uploader: FacebookVideo上传器实例
        max_retries: 最大重试次数
    """
    retries = 0
    last_error = None
    
    while retries <= max_retries:
        try:
            if retries > 0:
                print(f"Facebook上传重试 (第{retries}次)...")
            
            # 执行Facebook标准上传流程
            return await uploader.main()
            
        except Exception as e:
            last_error = e
            retries += 1
            
            # Facebook特定的重试策略
            error_message = str(e).lower()
            
            # 针对不同错误类型调整等待时间
            if 'timeout' in error_message or 'network' in error_message:
                wait_time = min(2 ** retries * 2, 60)  # 网络错误等待更长时间
            elif 'element' in error_message or 'selector' in error_message:
                wait_time = min(2 ** retries, 30)  # 元素定位错误等待较短时间
            else:
                wait_time = min(2 ** retries * 1.5, 45)  # 其他错误中等等待时间
            
            print(f"Facebook上传失败，{wait_time}秒后重试: {str(e)}")
            await asyncio.sleep(wait_time)
    
    # 重试次数用完，抛出最后一次错误
    print(f"Facebook上传最终失败: {str(last_error)}")
    raise last_error

# Facebook标准模式重试机制使用示例
async def facebook_upload_with_retry_example():
    """
    Facebook标准模式重试机制使用示例
    """
    uploader = FacebookVideo(
        title="测试视频",
        file_path="test_video.mp4",
        tags="测试,标签",
        publish_date=0,
        account_file="cookie.json",
        thumbnail_path="thumbnail.jpg"
    )
    
    try:
        # 使用重试机制执行上传
        result = await upload_with_retry_facebook(uploader, max_retries=3)
        print("Facebook上传成功！")
        return result
    except Exception as e:
        print(f"Facebook上传失败: {str(e)}")
        raise
```

## 7. 最佳实践

### 7.1 代码规范（Facebook标准模式）

新平台集成应遵循Facebook标准模式的代码规范：

1. **命名规范**
   - 类名使用驼峰命名法，如 `FacebookVideo`
   - 函数名使用下划线命名法，如 `upload_video_file`
   - 常量使用全大写，如 `PLATFORM_TYPE`
   - Facebook标准模式标识：在函数注释中添加"Facebook标准模式"说明

2. **注释规范**
   - 每个函数都要有docstring，说明功能、参数和返回值
   - 复杂逻辑要有行内注释
   - 关键步骤要有中文注释
   - Facebook特定的实现要注明"Facebook标准模式"

3. **错误处理**
   - 使用try-except捕获异常
   - 提供有意义的错误信息
   - 记录错误日志
   - Facebook标准模式：针对不同错误类型（网络、元素定位、超时）提供差异化处理

4. **代码结构**
   - 保持函数单一职责
   - 避免过长的函数（超过50行）
   - 合理使用异步编程
   - Facebook标准模式：采用面向对象设计，支持缩略图上传和商品链接功能

5. **Facebook标准模式特定规范**
   - 使用12步标准上传流程
   - 支持`thumbnail_path`参数
   - 支持`product_links`参数
   - 实现`set_schedule_time`定时发布功能
   - 使用Facebook特定的CSS选择器

1. **函数注释**：所有函数都必须添加详细的函数级注释，包括功能描述、参数说明和返回值
2. **异常处理**：全面的异常捕获和处理，避免程序崩溃
3. **日志记录**：关键操作和错误都需要记录日志，便于调试
4. **代码模块化**：合理拆分功能模块，提高代码复用性

### 7.2 安全性考虑（Facebook标准模式）

1. **Cookie管理（Facebook标准模式）**
   - 定期更新Cookie，避免过期（Facebook Cookie有效期约90天）
   - 使用安全的Cookie存储方式
   - 避免在日志中记录敏感信息
   - Facebook标准模式：使用`facebook_cookies.json`命名规范存储Cookie文件

2. **账号安全（Facebook标准模式）**
   - 使用代理IP，避免IP被封（Facebook对异常IP检测严格）
   - 控制发布频率，避免账号异常（Facebook建议间隔5-10分钟）
   - 监控账号状态，及时发现问题
   - Facebook标准模式：使用浏览器指纹模拟真实用户行为

3. **代码安全（Facebook标准模式）**
   - 避免硬编码敏感信息
   - 使用环境变量存储配置
   - 定期更新依赖库
   - Facebook标准模式：添加反自动化检测参数（`--disable-blink-features=AutomationControlled`）

4. **Facebook平台特定安全措施**
   - 使用真实的用户代理字符串
   - 模拟真实的鼠标移动和点击行为
   - 避免过快的操作速度
   - 使用Facebook特定的等待策略（`wait_until='domcontentloaded'`）

### 7.3 维护性建议（Facebook标准模式）

1. **模块化设计（Facebook标准模式）**
   - 将不同功能拆分成独立模块
   - 使用配置文件管理参数
   - 提供清晰的接口文档
   - Facebook标准模式：采用面向对象设计，支持继承和扩展

2. **日志记录（Facebook标准模式）**
   - 记录关键操作步骤（12步标准流程每步都要有日志）
   - 保存错误信息（包含Facebook特定的错误码和选择器信息）
   - 支持日志级别配置
   - Facebook标准模式：记录浏览器版本、Cookie状态等Facebook特定信息

3. **版本管理（Facebook标准模式）**
   - 使用Git进行版本控制
   - 编写更新日志
   - 保持向后兼容性
   - Facebook标准模式：跟踪Facebook平台API和UI变化，及时更新选择器

4. **测试覆盖（Facebook标准模式）**
   - 编写单元测试（测试FacebookVideo类的所有方法）
   - 进行集成测试（测试完整的12步上传流程）
   - 定期回归测试
   - Facebook标准模式：测试不同Facebook账号类型、不同视频格式的兼容性

## 8. 附录

### 8.1 平台类型编码表

| 平台名称 | 类型编码 |
|---------|--------|
| 小红书 | 1 |
| 视频号 | 2 |
| 抖音 | 3 |
| 快手 | 4 |
| NewPlatform | 5 |
| Instagram | 6 |
| Facebook | 7 |

### 8.2 常用Playwright API参考

```python
# 导航到页面
await page.goto('https://example.com')

# 等待元素出现
await page.wait_for_selector('#element-id')

# 填充输入框
await page.fill('#input-id', 'value')

# 点击元素
await page.click('#button-id')

# 获取元素文本
text = await page.inner_text('#element-id')

# 上传文件
await page.set_input_files('input[type="file"]', 'path/to/file')

# 等待导航完成
await page.wait_for_navigation()

# 执行JavaScript
result = await page.evaluate('() => document.title')
```

### 8.3 集成清单

#### 通用步骤（Facebook标准模式）
- [x] 创建平台上传器目录结构
- [x] 实现`__init__.py`文件
- [x] 实现平台配置文件（Facebook标准模式）
- [x] 实现核心上传类（Facebook标准模式 - FacebookVideo类）
- [x] 实现Cookie获取功能（Facebook标准模式）
- [x] 创建Cookie获取示例文件（Facebook标准模式）
- [x] 添加发布处理函数（Facebook标准模式）
- [x] 创建视频上传示例文件（Facebook标准模式）
- [x] 更新登录接口（Facebook标准模式）
- [x] 更新视频发布接口（Facebook标准模式）
- [x] 实现Cookie验证功能（Facebook标准模式）
- [ ] 编写单元测试（Facebook标准模式）
- [ ] 进行集成测试（Facebook标准模式）
- [x] 更新相关文档（Facebook标准模式）

#### Facebook平台特定集成（Facebook标准模式）
- [x] 创建Facebook上传器目录 `uploader/fb_uploader/`
- [x] 实现Facebook配置文件 `config.py`
- [x] 实现Facebook核心上传类 `main_chrome.py`（FacebookVideo类，12步标准流程）
- [x] 在`myUtils/login.py`中添加`get_facebook_cookie`函数（Facebook标准模式）
- [x] 在`myUtils/postVideo.py`中添加`post_video_Facebook`函数（Facebook标准模式）
- [x] 在`myUtils/auth.py`中添加`cookie_auth_facebook`函数（Facebook标准模式）
- [x] 更新`sau_backend.py`支持Facebook登录和发布（Facebook标准模式）
- [x] 创建Facebook Cookie获取示例 `examples/get_facebook_cookie.py`（Facebook标准模式）
- [x] 创建Facebook视频上传示例 `examples/upload_video_to_facebook.py`（Facebook标准模式）
- [x] 在平台类型编码表中添加Facebook（编码7）
- [x] 实现Facebook特定功能：缩略图上传、定时发布、商品链接
- [x] 实现Facebook性能优化：并发上传、重试机制（Facebook标准模式）
- [x] 遵循Facebook代码规范和安全考虑（Facebook标准模式）

---

本文档提供了完整的新平台集成流程指南，以Facebook标准模式为基准，遵循这些步骤和规范，可以高效地将新平台集成到现有系统中。

### Facebook标准模式特点总结

1. **面向对象设计**：使用`FacebookVideo`类封装所有上传逻辑
2. **12步标准上传流程**：标准化的视频上传步骤，确保稳定性
3. **功能完整性**：支持缩略图上传、定时发布、商品链接等高级功能
4. **错误处理优化**：针对不同错误类型提供差异化处理策略
5. **安全性增强**：添加反自动化检测参数，模拟真实用户行为
6. **性能优化**：支持并发上传和智能重试机制
7. **代码规范**：统一的命名规范和注释标准

在实际集成过程中，可能需要根据目标平台的具体特性进行适当调整，但建议以Facebook标准模式作为基础模板进行开发。