# 后端集成新平台指南

## 1. 文档概述

本文档详细描述了在视频发布系统中集成新的视频平台的完整流程和规范。遵循本文档的指导，可以快速、规范地将新平台集成到现有系统中，确保代码质量和系统稳定性。

## 2. 集成准备工作

### 2.1 环境要求

- Python 3.8+
- Flask
- Playwright (浏览器自动化)
- 其他依赖包 (见 requirements.txt)

### 2.2 平台调研

在开始集成前，需要对目标平台进行充分调研：

1. 平台的登录机制（账号密码、二维码、OAuth等）
2. 上传视频的限制（大小、时长、格式等）
3. 发布参数要求（标题、标签、分类等）
4. 是否支持定时发布功能
5. 平台特定的功能或限制

## 3. 集成步骤详解

### 3.1 创建平台上传器模块

#### 3.1.1 创建目录结构

在 `uploader` 目录下创建新的平台文件夹，例如 `newplatform_uploader`：

```
uploader/
└── newplatform_uploader/
    ├── __init__.py
    ├── main.py          # 核心上传实现（如使用Selenium）
    └── main_chrome.py   # Chrome/Playwright实现（可选）
```

对于Instagram平台，目录结构如下：
```
uploader/
└── ins_uploader/
    ├── __init__.py
    ├── main_chrome.py   # Instagram视频上传主类
    ├── instagram_logger.py  # Instagram专用日志模块
    └── config.py        # Instagram配置文件（可选）
```

#### 3.1.2 实现 `__init__.py`

```python
"""
NewPlatform平台上传器初始化文件
"""
from pathlib import Path
from conf import BASE_DIR

# 创建cookie存储目录
COOKIE_DIR = Path(BASE_DIR / "cookies" / "newplatform_uploader")
COOKIE_DIR.mkdir(parents=True, exist_ok=True)
```

#### 3.1.3 实现平台配置文件（可选）

如果平台有特殊的定位器或配置参数，可以创建专门的配置文件：

```python
"""
NewPlatform平台配置文件
"""

class NewPlatform_Locator:
    """NewPlatform平台元素定位器"""
    
    # 默认定位器
    default = {
        "login_button": "#login-button",
        "username_input": "#username",
        "password_input": "#password",
        "upload_button": "#upload-video",
        "file_input": "#video-file",
        "title_input": "#video-title",
        "tags_input": "#video-tags",
        "publish_button": "#publish-video"
    }
    
    # 特定场景下的定位器（如iframe内）
    iframe = {
        "frame_selector": "iframe#upload-frame",
        # iframe内的元素定位器
    }
```

#### 3.1.4 实现核心上传类

创建 `main_chrome.py` 文件，实现基于Playwright的上传逻辑：

```python
"""
NewPlatform平台视频上传核心实现
"""
import asyncio
import json
import logging
import os
from pathlib import Path
from datetime import datetime
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeoutError

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class NewPlatformVideo:
    """
    NewPlatform视频上传器类
    
    Args:
        title (str): 视频标题
        video_path (str): 视频文件路径
        tags (str): 话题标签，多个标签用空格分隔
        publish_time (int): 定时发布时间戳，0表示立即发布
        cookie_path (str): Cookie文件路径
        *platform_specific_args: 平台特定参数
    """
    
    def __init__(self, title, video_path, tags, publish_time, cookie_path, **kwargs):
        self.title = title
        self.video_path = video_path
        self.tags = tags
        self.publish_time = publish_time
        self.cookie_path = cookie_path
        self.browser = None
        self.page = None
        # 初始化平台特定参数
        self.platform_specific_params = kwargs
    
    async def init_browser(self):
        """
        初始化浏览器实例
        """
        try:
            playwright = await async_playwright().start()
            # 可配置无头/有头模式
            headless = os.environ.get('HEADLESS', 'false').lower() == 'true'
            self.browser = await playwright.chromium.launch(
                headless=headless,
                args=[
                    '--no-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-gpu',
                    '--ignore-certificate-errors'
                ]
            )
            self.page = await self.browser.new_page(
                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            )
            logger.info("浏览器初始化成功")
        except Exception as e:
            logger.error(f"浏览器初始化失败: {str(e)}")
            raise
    
    async def load_cookie(self):
        """
        加载Cookie文件
        """
        try:
            # 先导航到平台主页再加载Cookie
            await self.page.goto('https://www.newplatform.com')
            
            if os.path.exists(self.cookie_path):
                with open(self.cookie_path, 'r', encoding='utf-8') as f:
                    cookies = json.load(f)
                    await self.page.context.add_cookies(cookies)
                logger.info(f"成功加载Cookie文件: {self.cookie_path}")
            else:
                logger.warning(f"Cookie文件不存在: {self.cookie_path}")
                raise FileNotFoundError(f"Cookie文件不存在: {self.cookie_path}")
        except Exception as e:
            logger.error(f"加载Cookie失败: {str(e)}")
            raise
    
    async def navigate_to_upload_page(self):
        """
        导航到视频上传页面
        """
        try:
            await self.page.goto('https://www.newplatform.com/upload', wait_until='networkidle')
            # 验证是否成功导航到上传页面
            if 'upload' not in self.page.url:
                raise Exception("导航到上传页面失败")
            logger.info("成功导航到上传页面")
        except Exception as e:
            logger.error(f"导航到上传页面失败: {str(e)}")
            raise
    
    async def upload_video(self):
        """
        上传视频文件
        """
        try:
            # 确保视频文件存在
            if not os.path.exists(self.video_path):
                raise FileNotFoundError(f"视频文件不存在: {self.video_path}")
            
            # 上传文件
            file_input = await self.page.query_selector('input[type="file"]')
            if not file_input:
                raise Exception("未找到文件上传元素")
            
            await file_input.set_input_files(self.video_path)
            logger.info(f"开始上传视频: {self.video_path}")
            
            # 等待上传完成（这里需要根据平台特性自定义等待逻辑）
            await self.page.wait_for_selector('.upload-complete-indicator', timeout=300000)  # 5分钟超时
            logger.info("视频上传完成")
        except Exception as e:
            logger.error(f"视频上传失败: {str(e)}")
            raise
    
    async def set_video_info(self):
        """
        设置视频信息（标题、标签等）
        """
        try:
            # 设置标题
            title_input = await self.page.query_selector('#video-title')
            if title_input:
                await title_input.fill(self.title)
            
            # 设置标签
            tags_input = await self.page.query_selector('#video-tags')
            if tags_input:
                await tags_input.fill(self.tags)
            
            logger.info(f"成功设置视频信息: 标题='{self.title}', 标签='{self.tags}'")
        except Exception as e:
            logger.error(f"设置视频信息失败: {str(e)}")
            raise
    
    async def set_schedule_time(self):
        """
        设置定时发布时间
        """
        try:
            if self.publish_time <= 0:
                return  # 不需要定时发布
            
            # 点击定时发布按钮
            schedule_button = await self.page.query_selector('#schedule-button')
            if not schedule_button:
                logger.warning("未找到定时发布按钮，跳过定时设置")
                return
            
            await schedule_button.click()
            
            # 解析时间戳并设置日期时间（这里需要根据平台的时间选择器特性自定义）
            publish_datetime = datetime.fromtimestamp(self.publish_time)
            
            # 示例：设置日期和时间
            await self.page.fill('#date-input', publish_datetime.strftime('%Y-%m-%d'))
            await self.page.fill('#time-input', publish_datetime.strftime('%H:%M'))
            
            logger.info(f"成功设置定时发布时间: {publish_datetime}")
        except Exception as e:
            logger.error(f"设置定时发布时间失败: {str(e)}")
            raise
    
    async def set_platform_specific_info(self):
        """
        设置平台特定信息
        """
        try:
            # 根据平台特定参数设置额外信息
            # 例如：商品链接、封面选择、分类设置等
            if self.platform_specific_params:
                logger.info(f"应用平台特定参数: {self.platform_specific_params}")
                # 这里添加平台特定的设置逻辑
        except Exception as e:
            logger.error(f"设置平台特定信息失败: {str(e)}")
            raise
    
    async def publish(self):
        """
        发布视频
        """
        try:
            # 点击发布按钮
            publish_button = await self.page.query_selector('#publish-button')
            if not publish_button:
                raise Exception("未找到发布按钮")
            
            # 等待发布完成（这里需要根据平台特性自定义等待逻辑）
            async with self.page.expect_navigation(timeout=300000):
                await publish_button.click()
            
            logger.info(f"视频发布成功: {self.title}")
        except Exception as e:
            logger.error(f"视频发布失败: {str(e)}")
            raise
    
    async def close_browser(self):
        """
        关闭浏览器
        """
        try:
            if self.browser:
                await self.browser.close()
                logger.info("浏览器已关闭")
        except Exception as e:
            logger.error(f"关闭浏览器失败: {str(e)}")
    
    async def main(self):
        """
        主入口函数，协调整个上传流程
        """
        try:
            # 初始化浏览器
            await self.init_browser()
            
            # 加载Cookie
            await self.load_cookie()
            
            # 导航到上传页面
            await self.navigate_to_upload_page()
            
            # 上传视频
            await self.upload_video()
            
            # 设置视频信息（标题、标签等）
            await self.set_video_info()
            
            # 设置定时发布（如果需要）
            if self.publish_time > 0:
                await self.set_schedule_time()
            
            # 设置平台特定信息
            await self.set_platform_specific_info()
            
            # 发布视频
            await self.publish()
            
            logger.info(f"✅ 视频发布成功: {self.title}")
            return True
        except Exception as e:
            logger.error(f"❌ 视频发布失败: {str(e)}")
            raise
        finally:
            # 关闭浏览器
            await self.close_browser()

# 主函数调用示例
async def run_upload(title, video_path, tags, publish_time, cookie_path, **kwargs):
    """
    运行上传任务
    
    Args:
        title (str): 视频标题
        video_path (str): 视频文件路径
        tags (str): 标签
        publish_time (int): 发布时间戳
        cookie_path (str): Cookie路径
        **kwargs: 额外参数
    """
    uploader = NewPlatformVideo(title, video_path, tags, publish_time, cookie_path, **kwargs)
    return await uploader.main()

if __name__ == "__main__":
    # 示例运行代码
    asyncio.run(run_upload(
        "测试视频",
        "videos/demo.mp4",
        "测试 标签",
        0,  # 立即发布
        "cookies/newplatform_cookie.json"
    ))
```

### 3.2 实现Cookie获取功能

#### 3.2.1 在 `myUtils/login.py` 中添加新平台的Cookie生成函数

```python
async def newplatform_cookie_gen(account_id, status_queue):
    """
    生成NewPlatform平台的Cookie
    
    Args:
        account_id (str): 账号ID
        status_queue (Queue): 状态队列，用于返回登录状态
    """
    try:
        from pathlib import Path
        from conf import BASE_DIR
        from playwright.async_api import async_playwright
        
        # 创建cookie保存目录
        cookie_dir = Path(BASE_DIR / "cookiesFile")
        cookie_dir.mkdir(parents=True, exist_ok=True)
        
        cookie_file = cookie_dir / f"{account_id}_newplatform.json"
        
        async with async_playwright() as p:
            # 启动浏览器（建议使用有头模式以便用户交互）
            browser = await p.chromium.launch(headless=False)
            page = await browser.new_page()
            
            # 发送开始登录状态
            status_queue.put({"status": "start", "message": "开始登录NewPlatform"})
            
            # 导航到登录页面
            await page.goto("https://www.newplatform.com/login")
            
            # 等待用户手动登录
            status_queue.put({"status": "waiting", "message": "请在浏览器中完成登录"})
            
            # 等待登录成功的标识（需要根据平台特性自定义）
            await page.wait_for_selector('.user-avatar', timeout=300000)  # 5分钟超时让用户登录
            
            # 登录成功，获取并保存Cookie
            cookies = await page.context.cookies()
            
            with open(cookie_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            # 发送成功状态
            status_queue.put({"status": "success", "message": "登录成功，Cookie已保存"})
            
            # 关闭浏览器
            await browser.close()
            
    except Exception as e:
        status_queue.put({"status": "error", "message": f"获取Cookie失败: {str(e)}"})
        raise
```

#### 3.2.2 创建Cookie获取示例文件

在 `examples` 目录下创建 `get_newplatform_cookie.py`：

```python
"""
NewPlatform平台Cookie获取示例
"""
import asyncio
import json
from pathlib import Path
from conf import BASE_DIR

async def get_newplatform_cookie():
    """
    获取NewPlatform平台Cookie
    """
    try:
        from playwright.async_api import async_playwright
        
        # 创建cookie保存目录
        cookie_dir = Path(BASE_DIR / "cookiesFile")
        cookie_dir.mkdir(parents=True, exist_ok=True)
        
        cookie_file = cookie_dir / "newplatform_cookie.json"
        
        async with async_playwright() as p:
            # 启动浏览器
            browser = await p.chromium.launch(headless=False)
            page = await browser.new_page()
            
            print("正在打开NewPlatform登录页面，请手动登录...")
            
            # 导航到登录页面
            await page.goto("https://www.newplatform.com/login")
            
            # 等待用户手动登录完成
            print("请在浏览器中完成登录操作")
            
            # 等待登录成功的标识（需要根据平台特性自定义）
            await page.wait_for_selector('.user-avatar', timeout=300000)  # 5分钟超时
            
            # 获取并保存Cookie
            cookies = await page.context.cookies()
            
            with open(cookie_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            print(f"✅ Cookie已成功保存到: {cookie_file}")
            
            # 关闭浏览器
            await browser.close()
            
    except Exception as e:
        print(f"❌ 获取Cookie失败: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(get_newplatform_cookie())
```

在 `examples` 目录下创建 `get_instagram_cookie.py`：

```python
"""
Instagram平台Cookie获取示例
"""
import asyncio
import json
from pathlib import Path
from conf import BASE_DIR

async def get_instagram_cookie():
    """
    获取Instagram平台Cookie
    """
    try:
        from playwright.async_api import async_playwright
        
        # 创建cookie保存目录
        cookie_dir = Path(BASE_DIR / "cookiesFile")
        cookie_dir.mkdir(parents=True, exist_ok=True)
        
        cookie_file = cookie_dir / "instagram_cookie.json"
        
        async with async_playwright() as p:
            # 启动浏览器
            browser = await p.chromium.launch(headless=False)
            page = await browser.new_page()
            
            print("正在打开Instagram登录页面，请手动登录...")
            
            # 导航到登录页面
            await page.goto("https://www.instagram.com/accounts/login/")
            
            # 等待用户手动登录完成
            print("请在浏览器中完成登录操作")
            
            # 等待登录成功的标识（Instagram登录成功后会重定向到主页）
            await page.wait_for_selector('svg[aria-label="主页"]', timeout=300000)  # 5分钟超时
            
            # 获取并保存Cookie
            cookies = await page.context.cookies()
            
            with open(cookie_file, 'w', encoding='utf-8') as f:
                json.dump(cookies, f, ensure_ascii=False, indent=2)
            
            print(f"✅ Instagram Cookie已成功保存到: {cookie_file}")
            
            # 关闭浏览器
            await browser.close()
            
    except Exception as e:
        print(f"❌ 获取Instagram Cookie失败: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(get_instagram_cookie())
```

### 3.3 添加发布处理函数

#### 3.3.1 在 `myUtils/postVideo.py` 中添加新平台的发布函数

```python
def post_video_newplatform(title, files, tags, account_file, category, enableTimer, videos_per_day, daily_times, start_days, **platform_specific_args):
    """
    发布视频到NewPlatform平台
    
    Args:
        title (str): 视频标题
        files (list): 视频文件路径列表
        tags (str): 标签
        account_file (list): 账号cookie文件路径列表
        category (int): 分类
        enableTimer (bool): 是否启用定时发布
        videos_per_day (int): 每天发布视频数量
        daily_times (list): 每日发布时间点列表
        start_days (int): 开始天数
        **platform_specific_args: 平台特定参数
    """
    import asyncio
    from utils.files_times import generate_schedule_time_next_day
    
    try:
        # 导入平台上传器
        from uploader.newplatform_uploader.main_chrome import run_upload
        
        # 生成发布时间
        if enableTimer:
            publish_datetimes = generate_schedule_time_next_day(len(files), videos_per_day, daily_times, start_days)
        else:
            publish_datetimes = [0] * len(files)
        
        # 遍历执行发布
        for index, file in enumerate(files):
            for cookie in account_file:
                # 执行上传
                asyncio.run(run_upload(
                    title,
                    str(file),
                    tags,
                    publish_datetimes[index],
                    str(cookie),
                    **platform_specific_args
                ))
        
        return True
    except Exception as e:
        print(f"发布视频到NewPlatform失败: {str(e)}")
        raise
```

#### 3.3.2 创建视频上传示例文件

在 `examples` 目录下创建 `upload_video_to_newplatform.py`：

```python
"""
上传视频到NewPlatform平台示例
"""
import asyncio
from pathlib import Path
from conf import BASE_DIR

async def upload_to_newplatform():
    """
    上传视频到NewPlatform平台
    """
    try:
        # 导入平台上传器
        from uploader.newplatform_uploader.main_chrome import NewPlatformVideo
        
        # 视频文件路径
        video_path = Path(BASE_DIR / "videos/demo.mp4")
        
        # Cookie文件路径
        cookie_path = Path(BASE_DIR / "cookiesFile/newplatform_cookie.json")
        
        # 创建上传器实例
        uploader = NewPlatformVideo(
            title="测试视频标题",
            video_path=str(video_path),
            tags="测试 标签 示例",
            publish_time=0,  # 立即发布
            cookie_path=str(cookie_path)
            # 可以添加平台特定参数
        )
        
        # 执行上传
        await uploader.main()
        
        print("✅ 视频上传成功")
        
    except Exception as e:
        print(f"❌ 视频上传失败: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(upload_to_newplatform())
```

在 `examples` 目录下创建 `upload_video_to_instagram.py`：

```python
"""
上传视频到Instagram平台示例
"""
import asyncio
from pathlib import Path
from conf import BASE_DIR

async def upload_to_instagram():
    """
    上传视频到Instagram平台
    """
    try:
        # 导入平台上传器
        from uploader.ins_uploader.main_chrome import InstagramVideo
        
        # 视频文件路径
        video_path = Path(BASE_DIR / "videos/demo.mp4")
        
        # Cookie文件路径
        cookie_path = Path(BASE_DIR / "cookiesFile/instagram_cookie.json")
        
        # 创建上传器实例
        uploader = InstagramVideo(
            title="Instagram测试视频标题",
            video_path=str(video_path),
            tags="测试 标签 Instagram",
            publish_time=0,  # 立即发布
            cookie_path=str(cookie_path)
            # 可以添加Instagram平台特定参数
        )
        
        # 执行上传
        await uploader.main()
        
        print("✅ Instagram视频上传成功")
        
    except Exception as e:
        print(f"❌ Instagram视频上传失败: {str(e)}")
        raise

if __name__ == "__main__":
    asyncio.run(upload_to_instagram())
```

### 3.4 更新后端API

#### 3.4.1 更新登录接口

在 `sau_backend.py` 的登录接口中添加新平台的处理分支：

```python
# 在run_async_function函数中添加新平台的处理
async def run_async_function(type, id, status_queue):
    match type:
        case '1': await xiaohongshu_cookie_gen(id, status_queue)
        case '2': await get_tencent_cookie(id, status_queue)
        case '3': await douyin_cookie_gen(id, status_queue)
        case '4': await get_ks_cookie(id, status_queue)
        case '5': await newplatform_cookie_gen(id, status_queue)  # 添加新平台
        case '6': await get_instagram_cookie(id, status_queue)  # Instagram平台
        case '6': await get_instagram_cookie(id, status_queue)  # Instagram平台
```

#### 3.4.2 更新视频发布接口

在 `sau_backend.py` 的 `/postVideo` 接口中添加新平台的处理分支：

```python
@app.route('/postVideo', methods=['POST'])
def postVideo():
    # 获取请求数据
    data = request.get_json()
    file_list = data.get('fileList', [])
    account_list = data.get('accountList', [])
    type = data.get('type')  # 平台类型
    
    # 其他参数
    title = data.get('title')
    tags = data.get('tags')
    category = data.get('category')
    enableTimer = data.get('enableTimer')
    videos_per_day = data.get('videosPerDay', 1)
    daily_times = data.get('dailyTimes', ['00:00'])
    start_days = data.get('startDays', 0)
    
    # 平台特定参数
    # 提取新平台特定参数
    newplatform_params = {}
    # 根据平台需要提取特定参数
    
    # 根据平台类型调用对应发布函数
    match type:
        case 1:  # 小红书
            post_video_xhs(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days)
        case 2:  # 视频号
            post_video_tencent(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days, data.get('is_draft', False))
        case 3:  # 抖音
            post_video_DouYin(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days, data.get('thumbnail_path'), data.get('productLink'), data.get('productTitle'))
        case 4:  # 快手
            post_video_ks(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days)
        case 5:  # 新平台
            post_video_newplatform(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days, **newplatform_params)
        case 6:  # Instagram
            post_video_Instagram(title, file_list, tags, account_list, category, enableTimer, videos_per_day, daily_times, start_days)
    
    # 返回成功响应
    return jsonify({"code": 200, "msg": None, "data": None})
```

## 4. 平台特定功能实现指南

### 4.1 定时发布功能

不同平台的定时发布实现方式可能不同，主要有以下几种情况：

1. **时间戳方式**：直接传入Unix时间戳
2. **日期时间选择器**：需要分别设置日期和时间
3. **相对时间**：如设置为几小时后发布

实现时需要根据平台的具体API或界面进行适配。

### 4.2 封面设置功能

封面设置的实现方式：

1. **自动生成**：平台自动从视频中提取帧
2. **自定义上传**：允许上传自定义图片作为封面
3. **帧选择**：从视频中选择特定帧作为封面

实现代码示例：

```python
async def set_thumbnail(self, thumbnail_path=None):
    """
    设置视频封面
    
    Args:
        thumbnail_path (str, optional): 封面图片路径
    """
    try:
        if not thumbnail_path:
            # 使用自动生成的封面
            return
        
        # 点击封面上传按钮
        cover_button = await self.page.query_selector('#cover-upload-button')
        if cover_button:
            await cover_button.click()
            
            # 上传封面图片
            file_input = await self.page.query_selector('input[type="file"].cover-input')
            if file_input:
                await file_input.set_input_files(thumbnail_path)
                await self.page.wait_for_selector('.cover-upload-success', timeout=10000)
                logger.info(f"成功上传自定义封面: {thumbnail_path}")
    except Exception as e:
        logger.warning(f"设置封面失败: {str(e)}")
```

### 4.3 商品链接功能

电商相关平台通常支持添加商品链接：

```python
async def set_product_link(self, product_link=None, product_title=None):
    """
    设置商品链接
    
    Args:
        product_link (str, optional): 商品链接
        product_title (str, optional): 商品标题
    """
    try:
        if not product_link:
            return
        
        # 打开商品链接设置面板
        product_button = await self.page.query_selector('#add-product-button')
        if product_button:
            await product_button.click()
            
            # 填写商品信息
            if product_title:
                title_input = await self.page.query_selector('#product-title-input')
                if title_input:
                    await title_input.fill(product_title)
            
            link_input = await self.page.query_selector('#product-link-input')
            if link_input:
                await link_input.fill(product_link)
                await self.page.keyboard.press('Enter')
                
                # 等待验证成功
                await self.page.wait_for_selector('.product-link-validated', timeout=10000)
                logger.info(f"成功设置商品链接: {product_link}")
    except Exception as e:
        logger.warning(f"设置商品链接失败: {str(e)}")
```

## 5. 测试与验证

### 5.1 单元测试

为新平台上传器编写单元测试，确保核心功能正常：

```python
"""
NewPlatform上传器单元测试
"""
import unittest
from unittest.mock import patch, MagicMock
import asyncio
from uploader.newplatform_uploader.main_chrome import NewPlatformVideo

class TestNewPlatformVideo(unittest.TestCase):
    
    def setUp(self):
        self.title = "测试视频"
        self.video_path = "test_video.mp4"
        self.tags = "测试 标签"
        self.publish_time = 0
        self.cookie_path = "test_cookie.json"
        
    @patch('uploader.newplatform_uploader.main_chrome.async_playwright')
    async def test_init_browser(self, mock_playwright):
        # 模拟浏览器初始化
        mock_browser = MagicMock()
        mock_page = MagicMock()
        mock_context_manager = MagicMock()
        mock_context_manager.__aenter__.return_value.chromium.launch.return_value = mock_browser
        mock_browser.new_page.return_value = mock_page
        mock_playwright.return_value = mock_context_manager
        
        uploader = NewPlatformVideo(self.title, self.video_path, self.tags, self.publish_time, self.cookie_path)
        await uploader.init_browser()
        
        # 验证浏览器初始化
        mock_playwright.assert_called_once()
        mock_browser.new_page.assert_called_once()
        
    # 更多测试方法...
    
if __name__ == '__main__':
    unittest.main()
```

### 5.2 集成测试

进行端到端的集成测试，验证完整的上传流程：

1. 使用示例脚本测试Cookie获取功能
2. 使用示例脚本测试视频上传功能
3. 通过API接口测试完整的发布流程

### 5.3 常见问题排查

| 问题 | 可能原因 | 解决方案 |
|------|---------|--------|
| Cookie过期 | 平台Cookie有效期限制 | 实现Cookie自动刷新机制 |
| 上传超时 | 视频文件过大或网络问题 | 增加超时时间，优化上传逻辑 |
| 元素定位失败 | 平台页面更新 | 更新元素定位器，增加错误恢复机制 |
| 登录失败 | 账号密码错误或验证码 | 改进登录流程，增加用户交互提示 |

## 6. 性能优化建议

### 6.1 并发上传优化

对于多视频、多账号的发布场景，可以使用并发优化：

```python
async def batch_upload_videos(video_tasks):
    """
    并发上传多个视频
    
    Args:
        video_tasks (list): 视频任务列表，每个任务包含上传所需的参数
    """
    # 设置并发限制
    semaphore = asyncio.Semaphore(3)  # 最多同时执行3个上传任务
    
    async def upload_with_limit(task_params):
        async with semaphore:
            uploader = NewPlatformVideo(**task_params)
            return await uploader.main()
    
    # 创建任务并等待全部完成
    tasks = [upload_with_limit(params) for params in video_tasks]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    # 处理结果
    success_count = sum(1 for r in results if isinstance(r, bool) and r)
    error_count = sum(1 for r in results if isinstance(r, Exception))
    
    return {
        "total": len(results),
        "success": success_count,
        "error": error_count,
        "errors": [str(r) for r in results if isinstance(r, Exception)]
    }
```

### 6.2 重试机制实现

增加自动重试机制，提高上传成功率：

```python
async def upload_with_retry(uploader, max_retries=3):
    """
    带重试机制的上传函数
    
    Args:
        uploader: 上传器实例
        max_retries: 最大重试次数
    """
    retries = 0
    last_error = None
    
    while retries <= max_retries:
        try:
            if retries > 0:
                print(f"重试上传 (第{retries}次)...")
            return await uploader.main()
        except Exception as e:
            last_error = e
            retries += 1
            # 指数退避
            wait_time = min(2 ** retries, 60)  # 最多等待60秒
            print(f"上传失败，{wait_time}秒后重试: {str(e)}")
            await asyncio.sleep(wait_time)
    
    # 重试次数用完，抛出最后一次错误
    raise last_error
```

## 7. 最佳实践

### 7.1 代码规范

1. **函数注释**：所有函数都必须添加详细的函数级注释，包括功能描述、参数说明和返回值
2. **异常处理**：全面的异常捕获和处理，避免程序崩溃
3. **日志记录**：关键操作和错误都需要记录日志，便于调试
4. **代码模块化**：合理拆分功能模块，提高代码复用性

### 7.2 安全性考虑

1. **Cookie保护**：Cookie文件需要妥善保存，避免泄露
2. **输入验证**：对所有用户输入进行验证，防止恶意输入
3. **超时控制**：设置合理的超时时间，避免资源占用
4. **错误信息**：避免在错误信息中泄露敏感信息

### 7.3 维护性建议

1. **配置外部化**：将平台特定的配置参数外部化，便于维护
2. **版本控制**：记录平台API或页面的版本信息，方便后续更新
3. **兼容性处理**：针对平台可能的变更，增加兼容性处理逻辑
4. **文档更新**：及时更新相关文档，保持文档与代码同步

## 8. 附录

### 8.1 平台类型编码表

| 平台名称 | 类型编码 |
|---------|--------|
| 小红书 | 1 |
| 视频号 | 2 |
| 抖音 | 3 |
| 快手 | 4 |
| NewPlatform | 5 |
| Instagram | 6 |

### 8.2 常用Playwright API参考

```python
# 导航到页面
await page.goto('https://example.com')

# 等待元素出现
await page.wait_for_selector('#element-id')

# 填充输入框
await page.fill('#input-id', 'value')

# 点击元素
await page.click('#button-id')

# 获取元素文本
text = await page.inner_text('#element-id')

# 上传文件
await page.set_input_files('input[type="file"]', 'path/to/file')

# 等待导航完成
await page.wait_for_navigation()

# 执行JavaScript
result = await page.evaluate('() => document.title')
```

### 8.3 集成清单

- [ ] 创建平台上传器目录结构
- [ ] 实现`__init__.py`文件
- [ ] 实现平台配置文件（可选）
- [ ] 实现核心上传类
- [ ] 实现Cookie获取功能
- [ ] 创建Cookie获取示例文件
- [ ] 添加发布处理函数
- [ ] 创建视频上传示例文件
- [ ] 更新登录接口
- [ ] 更新视频发布接口
- [ ] 编写单元测试
- [ ] 进行集成测试
- [ ] 更新相关文档

---

本文档提供了完整的新平台集成流程指南，遵循这些步骤和规范，可以高效地将新平台集成到现有系统中。在实际集成过程中，可能需要根据目标平台的具体特性进行适当调整。